
Some more examples.

Linear Recursion:

(define (factorial n)
  (if (= n 1)
      1
    (* n (factorial (- n 1)))))


;; Note that I am going to collapse primitive expressions if I can, but in this case I can't
;; because every primitive multiplication has a compound procedure call as an operand.
(factorial 6)

(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
(* 720)



Linear iterative process:

while counter <= max-count
  product <- product * counter
  counter <- counter + 1


(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
    (fact-iter (* product counter) (+ counter 1) max-count)))

(define (factorial n)
  (fact-iter 1 1 n))


;; In this case, I can immediately reduce primitive expressions
;; because they don't have compound procedures as operands.
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720

The first method, called linear recursion, forces the computer to
remember more (proportional to n). The second method is called linear
iterative because the computer doesn't have to remember as much.

Technically, even though the 2nd method if recurisve, since it doesn't
have to remember anything about its current procedure call before
passing values to the next procedure call, we can call it tail-recursive.

We distinguish between the syntax of a procedure referring to itself ("the procodure is recursive")
and the fact that a process needs to maintain a chain of deferred computations ("the process
is recursive").

The latter is computational expensive the first is not necessarily so.

The implementation of scheme used by this book automatically detects
does tail-recursion when possible, but languages like C (and most
modern languages we use) do not automatically do tail recursion.

If you write a linearly iterative function that is theoretically
tail-recursive, you will still pay the computational penalty (your program
will run slower, or possibly blow up the stack).

Exercise 1.9.  Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))

(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

...

recursive process (chain of deferred commands can't complete without waiting on function calls)


(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

linear iterative process / tail-recursive procedure. process state is stored in only the arguments forwarded to next procedure call.


Exercise 1.10.  The following procedure computes a mathematical function called Ackermann's function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

What are the values of the following expressions?

(A 1 10)



(A 2 4)

(A 3 3)















